<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockBlast - Networking Edition</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1000px;
            gap: 20px;
        }
        .left-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #4fd1c5;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-align: center;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 2px;
            background-color: #555;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        .cell {
            width: 50px;
            height: 50px;
            background-color: #333;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .cell.filled {
            background-color: #4fd1c5;
        }
        .cell.highlight {
            background-color: #444; /* For valid placement */
        }
        .cell.highlight-invalid {
            background-color: #773333; /* For invalid placement attempt */
        }
        .blocks-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px; /* Gap from game board */
        }
        .block-selection {
            display: flex;
            flex-direction: column; /* Stack blocks vertically */
            gap: 15px; /* Space between blocks */
            margin-top: 20px;
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            min-width: 150px; /* Ensure it has some width */
        }
        .block {
            display: grid;
            gap: 2px;
            cursor: grab;
        }
        .block.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }
        .block-cell {
            width: 20px;
            height: 20px;
            background-color: #4fd1c5;
            border-radius: 2px;
        }
        .empty-cell { /* For spacing within a block's grid structure */
            width: 20px;
            height: 20px;
            background-color: transparent;
        }
        .score-panel {
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            width: 100%;
            min-width: 280px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        .score, .lives, .blocks-placed-count, .questions-answered-count {
            font-size: 1.2rem;
            margin-bottom: 8px;
        }
        .score { color: #4fd1c5; font-size: 1.4rem; }
        .lives { color: #f56565; }
        .blocks-placed-count { color: #d69e2e; }
        .questions-answered-count { color: #63b3ed; }

        .question-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            visibility: hidden; opacity: 0; transition: opacity 0.3s, visibility 0.3s;
        }
        .question-container {
            background-color: #333; padding: 30px; border-radius: 10px;
            max-width: 700px; 
            width: 90%; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .question-text { font-size: 1.2rem; margin-bottom: 10px; color: #4fd1c5; }
        .question-level-text { font-size: 0.9rem; margin-bottom: 15px; color: #aaa; }
        .answers { display: flex; flex-direction: column; gap: 10px; }
        .answer-btn {
            padding: 12px 15px; background-color: #4a5568; color: white;
            border: none; border-radius: 5px; cursor: pointer;
            font-size: 1rem; transition: background-color 0.2s; text-align: left;
            line-height: 1.4;
        }
        .answer-btn:hover { background-color: #2d3748; }

        .game-controls { display: flex; justify-content: center; gap: 20px; margin-top: 20px; }
        .control-btn {
            padding: 10px 20px; background-color: #4fd1c5; color: #222;
            border: none; border-radius: 5px; cursor: pointer;
            font-weight: bold; transition: background-color 0.2s;
        }
        .control-btn:hover { background-color: #38b2ac; }

        .game-over {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            visibility: hidden; opacity: 0; transition: opacity 0.3s, visibility 0.3s;
        }
        .game-over-container {
            background-color: #333; padding: 30px; border-radius: 10px;
            max-width: 400px; width: 90%; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .game-over-title { font-size: 2rem; color: #f56565; margin-bottom: 15px; }
        .final-score { font-size: 1.5rem; margin-bottom: 15px; }
        .game-over-message { font-size: 1.1rem; color: #ddd; margin-bottom: 25px; }
        .restart-btn {
            padding: 10px 25px; background-color: #4fd1c5; color: #222;
            border: none; border-radius: 5px; cursor: pointer;
            font-weight: bold; font-size: 1.1rem;
        }
        .restart-btn:hover { background-color: #38b2ac; }

        .tutorial-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
        }
        .tutorial-container {
            background-color: #333; padding: 30px; border-radius: 10px;
            max-width: 600px; width: 90%; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            text-align: left;
        }
        .tutorial-title { font-size: 1.8rem; color: #4fd1c5; margin-bottom: 15px; text-align: center;}
        .tutorial-content { margin-bottom: 20px; line-height: 1.6; }
        .tutorial-content ul { padding-left: 20px; }
        .start-game-btn {
            padding: 10px 25px; background-color: #4fd1c5; color: #222;
            border: none; border-radius: 5px; cursor: pointer;
            font-weight: bold; font-size: 1.1rem; display: block; margin: 20px auto 0 auto;
        }
    </style>
</head>
<body>
    <h1>BlockBlast - Level 3: Addressing</h1>
    
    <div class="game-container">
        <div class="left-panel">
            <div class="game-board" id="gameBoard"></div>
            <div class="score-panel">
                <div class="score" id="score">Score: 0</div>
                <div class="lives" id="lives">Lives: 3</div>
                <div class="blocks-placed-count" id="blocksPlaced">Blocks Placed: 0/2</div>
                <div class="questions-answered-count" id="questionsAnswered">Questions: 0/0</div>
            </div>
        </div>
        
        <div class="blocks-container">
            <h2>Available Blocks</h2>
            <div class="block-selection" id="blockSelection"></div>
            <div class="game-controls">
                <button class="control-btn" id="restartBtn">Restart Game</button>
            </div>
        </div>
    </div>
    
    <div class="question-modal" id="questionModal">
        <div class="question-container">
            <div class="question-text" id="questionText"></div>
            <div class="question-level-text" id="questionLevelText"></div>
            <div class="answers" id="answers"></div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <div class="game-over-container">
            <div class="game-over-title" id="gameOverTitle">Game Over!</div>
            <div class="final-score" id="finalScore">Your final score: 0</div>
            <div class="game-over-message" id="gameOverMessage"></div>
            <button class="restart-btn" id="gameOverRestartBtn">Play Again</button>
        </div>
    </div>

    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-container">
            <div class="tutorial-title">Welcome to BlockBlast - Networking Edition!</div>
            <div class="tutorial-content">
                <p><strong>How to play:</strong></p>
                <ul>
                    <li>Drag the Tetris-like blocks onto the 8x8 grid.</li>
                    <li>Complete a full row or column of 8 cells to clear it and earn points.</li>
                    <li>After placing 2 blocks, a networking question will appear.</li>
                    <li>Answer correctly for bonus points. Incorrect answers cost a life.</li>
                    <li>Lose 3 lives, or run out of moves/questions, and the game ends.</li>
                    <li>The game tracks the number of unique questions answered out of 20.</li>
                    <li>Try to get the highest score!</li>
                </ul>
            </div>
            <button class="start-game-btn" id="startGameBtn">Start Game</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let score = 0;
            let lives = 3;
            let blocksPlaced = 0;
            let gameGrid = Array(8).fill(null).map(() => Array(8).fill(0));
            let draggingBlock = null;
            let dragStartPos = { shapeClickRow: 0, shapeClickCol: 0 };
            const blockShapes = [
                { shape: [[1, 1, 1, 1]], color: '#FF5252' }, { shape: [[1, 0], [1, 0], [1, 1]], color: '#FFD740' },
                { shape: [[0, 1], [0, 1], [1, 1]], color: '#7C4DFF' }, { shape: [[1, 1], [1, 1]], color: '#FF4081' },
                { shape: [[1, 1, 1], [0, 1, 0]], color: '#64FFDA' }, { shape: [[1, 1, 0], [0, 1, 1]], color: '#18FFFF' },
                { shape: [[0, 1, 1], [1, 1, 0]], color: '#76FF03' }, { shape: [[1,1]], color: '#B388FF' },
                { shape: [[1,1,1]], color: '#FF9E80' }, { shape: [[1]], color: '#EA80FC' }
            ];
            
            let availableBlocks = [];
const networkingQuestions = [
    {
        question: "MAC Address",
        level: "MAC Addressing",
        answers: [
            "A 48-bit address organized as six hex numbers separated by colons. Also called a physical address, it identifies network interfaces at the Data Link layer.", // Correct (Position 0)
            "A 128-bit address used for the next generation of internet protocol, written in hexadecimal.",
            "A dynamic address assigned by a DHCP server for temporary network access.",
            "A textual name that corresponds to the numeric IP address of a device on a network."
        ],
        correctAnswer: 0
    },
    {
        question: "OUI",
        level: "MAC Addressing",
        answers: [
            "The last 24 bits of a MAC address, assigned by the manufacturer to ensure uniqueness.",
            "Organizationally Unique Identifier. The first 24 bits of a MAC address that identify the manufacturer. Assigned by the IEEE.", // Correct (Position 1)
            "A globally unique identifier used to distinguish individual network devices on the internet.",
            "A standard for wireless network security protocols like WPA3."
        ],
        correctAnswer: 1
    },
    {
        question: "Device ID",
        level: "MAC Addressing",
        answers: [
            "The first 24 bits of a MAC address that identify the vendor of the network interface.",
            "A user-configurable name for a device on a network, like 'MyLaptop'.",
            "The last 24 bits of a MAC address that make up the extension identifier. Assigned by manufacturers to ensure each NIC has a unique ID.", // Correct (Position 2)
            "A unique serial number physically printed on the network device itself for warranty purposes."
        ],
        correctAnswer: 2
    },
    {
        question: "IPv4 Address",
        level: "IPv4 Addressing",
        answers: [
            "A 48-bit hardware address permanently assigned to a network interface card.",
            "A 128-bit address designed to replace IPv4, offering a vastly larger address space.",
            "A number used to identify a specific application or service on a network device.",
            "A 32-bit address organized into four groups of 8 bits each (octets). Each octet can be any number from 0 to 255." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Static IP Address",
        level: "IPv4 Addressing",
        answers: [
            "An IP address assigned manually by the network administrator.", // Correct (Position 0)
            "An IP address that is automatically assigned by a DHCP server and may change over time.",
            "A private IP address that is not routable on the public internet.",
            "The IP address of a DNS server used for name resolution."
        ],
        correctAnswer: 0
    },
    {
        question: "Dynamic IP Address",
        level: "IPv4 Addressing",
        answers: [
            "A permanent IP address that does not change and is configured manually.",
            "An IP address automatically assigned by a DHCP (Dynamic Host Configuration Protocol) server.", // Correct (Position 1)
            "An IP address that is used for broadcasting messages to all devices on a subnet.",
            "The fixed physical address of a network interface card."
        ],
        correctAnswer: 1
    },
    {
        question: "Subnet Mask",
        level: "IPv4 Addressing",
        answers: [
            "The IP address of the router that allows devices to connect to other networks.",
            "A mechanism for translating private IP addresses to a public IP address.",
            "Used to indicate what portion of an IP address is the network portion (network ID) and what part is the host portion (host ID).", // Correct (Position 2)
            "A 48-bit hardware address unique to each network interface."
        ],
        correctAnswer: 2
    },
    {
        question: "Gateway",
        level: "IPv4 Addressing",
        answers: [
            "A server that assigns IP addresses dynamically to clients on a network.",
            "A device that filters traffic based on a set of security rules.",
            "A central point in a network that connects multiple Ethernet segments.",
            "Device that nodes use for access to the outside world or other networks." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "NAT",
        level: "IPv4 Addressing",
        answers: [
            "Network Address Translation. A technique designed to conserve public IP addresses by substituting private IP addresses with a public address when accessing external networks.", // Correct (Position 0)
            "A protocol for resolving human-readable domain names into IP addresses.",
            "A security feature that encrypts data transmitted over a network.",
            "A method for assigning IP addresses to devices manually."
        ],
        correctAnswer: 0
    },
    {
        question: "IPv6 Address",
        level: "IPv6 Addressing",
        answers: [
            "A 32-bit address written as four decimal numbers separated by dots.",
            "A 128-bit address written as eight blocks of hexadecimal numbers separated by colons. Example: 2001:0000:0B80:0000:0000:00D3:9C5A:00CC", // Correct (Position 1)
            "A 48-bit physical address burned into the network interface card.",
            "A temporary address assigned by a DHCP server for IPv4 networks."
        ],
        correctAnswer: 1
    },
    {
        question: "Link Local Address",
        level: "IPv6 Addressing",
        answers: [
            "An IPv6 address that is globally routable on the internet, typically starting with 2000::/3.",
            "A special IPv6 address (::1) that refers to the local host itself.",
            "An IPv6 address beginning with FE80 that can be used for communicating with nodes in the same link.", // Correct (Position 2)
            "An address used to send a packet to the nearest interface in a group of interfaces (anycast)."
        ],
        correctAnswer: 2
    },
    {
        question: "Global Unicast Address",
        level: "IPv6 Addressing",
        answers: [
            "An IPv6 address used only for communication within the same local network segment (e.g., FE80::).",
            "An IPv6 address that sends packets to all nodes on a specific segment.",
            "A reserved IPv6 address used for documentation and examples like 2001:DB8::/32.",
            "An IPv6 address that can be routed on the Internet. Begins with 2000::/3." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Port Number",
        level: "Ports & Sockets",
        answers: [
            "Ensures data is transmitted to the correct process among multiple processes running on a computer.", // Correct (Position 0)
            "The unique IP address assigned to a device on a network.",
            "The physical connector on a device where a network cable is plugged in.",
            "A hardware address embedded in the network interface card."
        ],
        correctAnswer: 0
    },
    {
        question: "Socket",
        level: "Ports & Sockets",
        answers: [
            "A numerical identifier for a specific application or service, ranging from 0 to 65535.",
            "Consists of a host's IP address and the port number of an application running on the host, separated by a colon (e.g., 10.43.3.87:23).", // Correct (Position 1)
            "A protocol used for reliable data transmission over a network like TCP.",
            "A physical interface on a switch or router used for network connections."
        ],
        correctAnswer: 1
    },
    {
        question: "Well-Known Ports",
        level: "Ports & Sockets",
        answers: [
            "Port numbers from 1024 to 49151 that can be registered by software vendors for their applications.",
            "Port numbers from 49152 to 65535 used for temporary client-side connections (ephemeral ports).",
            "Port numbers from 0 to 1023 reserved for common services and applications.", // Correct (Position 2)
            "Any port number that has been manually configured by a network administrator for a custom application."
        ],
        correctAnswer: 2
    },
    {
        question: "DNS",
        level: "DNS & Domain Names",
        answers: [
            "A protocol that automatically assigns IP addresses to devices on a network.",
            "A system for translating private IP addresses to public IP addresses when accessing the internet.",
            "A set of rules governing how data is formatted, addressed, transmitted, routed, and received.",
            "Domain Name System. An Application layer client-server system of computers and databases that translates domain names to IP addresses." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "FQDN",
        level: "DNS & Domain Names",
        answers: [
            "Fully Qualified Domain Name. A unique character-based name that identifies a host on a network.", // Correct (Position 0)
            "The numerical IP address assigned to a specific web server or network host.",
            "The first part of a domain name that identifies a specific host, like 'www' or 'mail'.",
            "A short alias or nickname that points to a longer, canonical domain name."
        ],
        correctAnswer: 0
    },
    {
        question: "Name Resolution",
        level: "DNS & Domain Names",
        answers: [
            "The process of assigning an IP address to a device when it joins a network via DHCP.",
            "The process of discovering the IP address of a host when you know its FQDN.", // Correct (Position 1)
            "The process of converting a private IP address to a public IP address using NAT.",
            "The process of verifying a user's credentials before granting network access."
        ],
        correctAnswer: 1
    },
    {
        question: "Primary DNS Server",
        level: "DNS & Domain Names",
        answers: [
            "A DNS server that forwards name resolution requests to other DNS servers if it cannot resolve them locally.",
            "A backup DNS server that takes over operations if the main DNS server fails.",
            "The authoritative name server for an organization that holds the authoritative DNS database for the organization's zones.", // Correct (Position 2)
            "Any DNS server that a client computer is configured to use for resolving domain names to IP addresses."
        ],
        correctAnswer: 2
    }
];
            let askedQuestionIndices = [];
            let currentQuestionObject = null;
            let gameIsOver = false;
            
            const gameBoardElement = document.getElementById('gameBoard');
            const blockSelectionElement = document.getElementById('blockSelection');
            const scoreElement = document.getElementById('score');
            const livesElement = document.getElementById('lives');
            const blocksPlacedElement = document.getElementById('blocksPlaced');
            const questionsAnsweredElement = document.getElementById('questionsAnswered');
            const questionModalElement = document.getElementById('questionModal');
            const questionTextElement = document.getElementById('questionText');
            const questionLevelTextElement = document.getElementById('questionLevelText');
            const answersContainerElement = document.getElementById('answers');
            const gameOverModalElement = document.getElementById('gameOver');
            const finalScoreElement = document.getElementById('finalScore');
            const gameOverTitleElement = document.getElementById('gameOverTitle');
            const gameOverMessageElement = document.getElementById('gameOverMessage');
            const restartBtnElement = document.getElementById('restartBtn');
            const gameOverRestartBtnElement = document.getElementById('gameOverRestartBtn');
            const tutorialOverlayElement = document.getElementById('tutorialOverlay');
            const startGameBtnElement = document.getElementById('startGameBtn');
            
            function initializeBoard() {
                gameBoardElement.innerHTML = '';
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        gameBoardElement.appendChild(cell);
                        cell.addEventListener('dragover', allowDrop);
                        cell.addEventListener('drop', dropBlock);
                        cell.addEventListener('dragenter', function(e) {
                            if (draggingBlock) {
                                const r = parseInt(e.target.dataset.row);
                                const c = parseInt(e.target.dataset.col);
                                highlightValidCells(r, c, draggingBlock.shape);
                            }
                        });
                        cell.addEventListener('dragleave', clearHighlight);
                    }
                }
                updateBoardVisuals();
            }
            
            function generateBlocks() {
                blockSelectionElement.innerHTML = '';
                availableBlocks = [];
                const numBlocksToGenerate = Math.min(3, blockShapes.length);
                for (let i = 0; i < numBlocksToGenerate; i++) {
                    const randomIndex = Math.floor(Math.random() * blockShapes.length);
                    const blockData = blockShapes[randomIndex];
                    const newBlock = {
                        shape: blockData.shape,
                        color: blockData.color,
                        id: `block-${Date.now()}-${i}`
                    };
                    availableBlocks.push(newBlock);
                    createBlockElement(newBlock.shape, newBlock.color, newBlock.id);
                }
            }
            
            function createBlockElement(shape, color, id) {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'block';
                blockDiv.id = id;
                blockDiv.draggable = true;
                const rows = shape.length;
                const cols = shape[0] ? shape[0].length : 0;
                blockDiv.style.gridTemplateColumns = `repeat(${cols}, 20px)`;
                blockDiv.style.gridTemplateRows = `repeat(${rows}, 20px)`;
                for (let r_shape = 0; r_shape < rows; r_shape++) {
                    for (let c_shape = 0; c_shape < cols; c_shape++) {
                        const cell = document.createElement('div');
                        if (shape[r_shape] && shape[r_shape][c_shape] === 1) {
                            cell.className = 'block-cell';
                            cell.style.backgroundColor = color;
                        } else {
                            cell.className = 'empty-cell';
                        }
                        blockDiv.appendChild(cell);
                    }
                }
                blockDiv.addEventListener('dragstart', function(e) {
                    draggingBlock = availableBlocks.find(b => b.id === id);
                    if (!draggingBlock) return;
                    e.dataTransfer.setData('text/plain', id);
                    e.target.classList.add('dragging');
                    let clickedShapeRow = 0, clickedShapeCol = 0;
                    const blockCells = e.target.querySelectorAll('.block-cell, .empty-cell');
                    blockCells.forEach((cell, index) => {
                        const cellRect = cell.getBoundingClientRect();
                        if (e.clientX >= cellRect.left && e.clientX < cellRect.right &&
                            e.clientY >= cellRect.top && e.clientY < cellRect.bottom) {
                            clickedShapeRow = Math.floor(index / cols);
                            clickedShapeCol = index % cols;
                        }
                    });
                    dragStartPos = { shapeClickRow: clickedShapeRow, shapeClickCol: clickedShapeCol };
                });
                blockDiv.addEventListener('dragend', function(e) {
                    e.target.classList.remove('dragging');
                    clearHighlight();
                    draggingBlock = null;
                });
                blockSelectionElement.appendChild(blockDiv);
            }
            
            function updateBoardVisuals() {
                gameBoardElement.querySelectorAll('.cell').forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    cell.className = 'cell'; 
                    if (gameGrid[row][col] === 1) cell.classList.add('filled');
                });
            }

            function highlightValidCells(boardCellRow, boardCellCol, shape) {
                clearHighlight();
                if (!draggingBlock) return;
                const startRow = boardCellRow - dragStartPos.shapeClickRow;
                const startCol = boardCellCol - dragStartPos.shapeClickCol;
                let canPlaceCurrent = true;
                for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                    for (let c_shape = 0; c_shape < (shape[r_shape] ? shape[r_shape].length : 0); c_shape++) {
                        if (shape[r_shape][c_shape] === 1) {
                            const R_board = startRow + r_shape;
                            const C_board = startCol + c_shape;
                            if (R_board < 0 || R_board >= 8 || C_board < 0 || C_board >= 8 || gameGrid[R_board][C_board] === 1) {
                                canPlaceCurrent = false;
                            }
                        }
                    }
                }
                for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                    for (let c_shape = 0; c_shape < (shape[r_shape] ? shape[r_shape].length : 0); c_shape++) {
                        if (shape[r_shape][c_shape] === 1) {
                            const R_board = startRow + r_shape;
                            const C_board = startCol + c_shape;
                            if (R_board >= 0 && R_board < 8 && C_board >= 0 && C_board < 8) {
                                const cellElement = gameBoardElement.querySelector(`.cell[data-row="${R_board}"][data-col="${C_board}"]`);
                                if (cellElement) {
                                    cellElement.classList.add(canPlaceCurrent && gameGrid[R_board][C_board] === 0 ? 'highlight' : 'highlight-invalid');
                                }
                            }
                        }
                    }
                }
            }
            
            function clearHighlight() {
                gameBoardElement.querySelectorAll('.cell.highlight, .cell.highlight-invalid').forEach(cell => {
                    cell.classList.remove('highlight', 'highlight-invalid');
                });
            }
            
            function allowDrop(e) { e.preventDefault(); }
            
            function dropBlock(e) {
                e.preventDefault();
                if (!draggingBlock) return;
                const targetCell = e.target.closest('.cell');
                if (!targetCell) { draggingBlock = null; clearHighlight(); return; }
                const boardCellRow = parseInt(targetCell.dataset.row);
                const boardCellCol = parseInt(targetCell.dataset.col);
                const startRow = boardCellRow - dragStartPos.shapeClickRow;
                const startCol = boardCellCol - dragStartPos.shapeClickCol;
                
                if (canPlaceBlock(draggingBlock.shape, startRow, startCol)) {
                    placeBlockOnGrid(draggingBlock.shape, startRow, startCol);
                    document.getElementById(draggingBlock.id)?.remove();
                    availableBlocks = availableBlocks.filter(b => b.id !== draggingBlock.id);
                    checkCompletedLines(); // This might call checkGameEndConditions indirectly if lines clear
                    blocksPlaced++;
                    blocksPlacedElement.textContent = `Blocks Placed: ${blocksPlaced % 2}/2`;
                    if (blocksPlaced % 2 === 0) {
                         setTimeout(showQuestion, 300);
                    } else { // If not showing a question, check end conditions now
                        checkGameEndConditions();
                    }
                    if (availableBlocks.length === 0 && networkingQuestions.length > askedQuestionIndices.length) {
                        generateBlocks();
                    }
                } else { // If block couldn't be placed, still check end conditions
                     checkGameEndConditions();
                }
                draggingBlock = null;
                clearHighlight();
            }

            function canPlaceBlock(shape, startRow, startCol) {
                for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                    for (let c_shape = 0; c_shape < (shape[r_shape] ? shape[r_shape].length : 0); c_shape++) {
                        if (shape[r_shape][c_shape] === 1) {
                            const R_board = startRow + r_shape;
                            const C_board = startCol + c_shape;
                            if (R_board < 0 || R_board >= 8 || C_board < 0 || C_board >= 8 || gameGrid[R_board][C_board] === 1) return false;
                        }
                    }
                }
                return true;
            }

            function canAnyBlockFromListFit(blockList) {
                if (!blockList || blockList.length === 0) return false;
                for (const block of blockList) {
                    const shapeToTest = block.shape;
                    for (let r_board_anchor = 0; r_board_anchor < 8; r_board_anchor++) {
                        for (let c_board_anchor = 0; c_board_anchor < 8; c_board_anchor++) {
                            for (let sr = 0; sr < shapeToTest.length; sr++) {
                                for (let sc = 0; sc < (shapeToTest[sr] ? shapeToTest[sr].length : 0); sc++) {
                                    if (shapeToTest[sr][sc] === 1) {
                                        const potentialStartRow = r_board_anchor - sr;
                                        const potentialStartCol = c_board_anchor - sc;
                                        if (canPlaceBlock(shapeToTest, potentialStartRow, potentialStartCol)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            }

            function canAnyNewShapeFit() {
                for (const baseBlock of blockShapes) {
                    const shapeToTest = baseBlock.shape;
                     for (let r_board_anchor = 0; r_board_anchor < 8; r_board_anchor++) {
                        for (let c_board_anchor = 0; c_board_anchor < 8; c_board_anchor++) {
                            for (let sr = 0; sr < shapeToTest.length; sr++) {
                                for (let sc = 0; sc < (shapeToTest[sr] ? shapeToTest[sr].length : 0); sc++) {
                                    if (shapeToTest[sr][sc] === 1) {
                                        const potentialStartRow = r_board_anchor - sr;
                                        const potentialStartCol = c_board_anchor - sc;
                                        if (canPlaceBlock(shapeToTest, potentialStartRow, potentialStartCol)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            }

            function placeBlockOnGrid(shape, startRow, startCol) {
                for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                    for (let c_shape = 0; c_shape < (shape[r_shape] ? shape[r_shape].length : 0); c_shape++) {
                        if (shape[r_shape][c_shape] === 1) {
                             const R_board = startRow + r_shape;
                             const C_board = startCol + c_shape;
                             if (R_board >= 0 && R_board < 8 && C_board >= 0 && C_board < 8) gameGrid[R_board][C_board] = 1;
                        }
                    }
                }
                updateBoardVisuals();
            }
            
            function checkCompletedLines() {
                let rowsToClear = [], colsToClear = [];
                for (let i = 0; i < 8; i++) {
                    if (gameGrid[i].every(cell => cell === 1)) rowsToClear.push(i);
                    let colIsFull = true;
                    for(let k=0; k<8; k++) if(gameGrid[k][i] === 0) {colIsFull = false; break;}
                    if(colIsFull) colsToClear.push(i);
                }
                if (rowsToClear.length > 0 || colsToClear.length > 0) {
                    setTimeout(() => {
                        clearLines(rowsToClear, colsToClear);
                        updateScore((rowsToClear.length + colsToClear.length) * 100);
                        // After clearing lines, new spaces might open up, so check game end conditions again.
                        // Also, if new blocks are needed and can be generated, do it.
                        if (availableBlocks.length === 0 && networkingQuestions.length > askedQuestionIndices.length) {
                            generateBlocks();
                        }
                        checkGameEndConditions();
                    }, 150); 
                } else {
                    // If no lines cleared, still check game end conditions as a block was just placed.
                    checkGameEndConditions();
                }
            }

            function clearLines(rows, cols) {
                rows.forEach(rowIndex => gameGrid[rowIndex].fill(0));
                cols.forEach(colIndex => gameGrid.forEach(row => row[colIndex] = 0));
                // Row gravity
                rows.sort((a, b) => b - a); 
                rows.forEach(clearedRowIndex => {
                    for (let r = clearedRowIndex; r > 0; r--) gameGrid[r] = [...gameGrid[r-1]];
                    gameGrid[0].fill(0);
                });
                // Column gravity (simplified - only if a full column was cleared, shift from right to left if implementing)
                // For this version, we'll stick to dominant row gravity which is more common.
                updateBoardVisuals();
            }
            
            function updateScore(points) {
                score += points;
                scoreElement.textContent = `Score: ${score}`;
            }
            
            function showQuestion() {
                if (gameIsOver) return;
                if (askedQuestionIndices.length >= networkingQuestions.length) {
                    checkGameEndConditions(); return;
                }
                let questionIndex;
                do { questionIndex = Math.floor(Math.random() * networkingQuestions.length); }
                while (askedQuestionIndices.includes(questionIndex));
                askedQuestionIndices.push(questionIndex);
                currentQuestionObject = networkingQuestions[questionIndex];
                questionTextElement.textContent = currentQuestionObject.question;
                questionLevelTextElement.textContent = `Level: ${currentQuestionObject.level}`;
                questionsAnsweredElement.textContent = `Questions: ${askedQuestionIndices.length}/${networkingQuestions.length}`;
                answersContainerElement.innerHTML = '';
                currentQuestionObject.answers.forEach((answer, index) => {
                    const button = document.createElement('button');
                    button.className = 'answer-btn';
                    button.textContent = answer;
                    button.dataset.index = index;
                    button.addEventListener('click', handleAnswer);
                    answersContainerElement.appendChild(button);
                });
                questionModalElement.style.visibility = 'visible';
                questionModalElement.style.opacity = '1';
            }

            function handleAnswer(event) {
                if (gameIsOver || !currentQuestionObject) return;
                const answerIndex = parseInt(event.target.dataset.index);
                if (answerIndex === currentQuestionObject.correctAnswer) {
                    updateScore(50);
                } else {
                    lives--;
                    livesElement.textContent = `Lives: ${lives}`;
                }
                hideQuestionModal();
                currentQuestionObject = null;
                checkGameEndConditions(); // Critical to check after answer processed
            }

            function checkGameEndConditions() {
                if (gameIsOver) return;
                if (lives <= 0) { endGame("No lives left!"); return; }
                
                const allQuestionsAnswered = askedQuestionIndices.length >= networkingQuestions.length;

                if (allQuestionsAnswered) { // If all questions are done, game ends if no more moves
                    if (availableBlocks.length === 0 || !canAnyBlockFromListFit(availableBlocks)) {
                        endGame("All questions answered and no more moves!");
                        return;
                    }
                }
                
                // Standard game over conditions if questions remain or even if all answered but moves still exist
                if (availableBlocks.length === 0 && !canAnyNewShapeFit()) {
                    endGame("No more blocks and no new shapes can fit!");
                    return;
                }
                if (availableBlocks.length > 0 && !canAnyBlockFromListFit(availableBlocks)) {
                     endGame("No more valid moves with available blocks!");
                     return;
                }
            }
            
            function hideQuestionModal() {
                questionModalElement.style.visibility = 'hidden';
                questionModalElement.style.opacity = '0';
            }
            
            function endGame(reason = "Game Over!") {
                if (gameIsOver) return;
                gameIsOver = true;
                gameOverTitleElement.textContent = "Game Over!";
                gameOverMessageElement.textContent = reason;
                finalScoreElement.textContent = `Your final score: ${score}`;
                gameOverModalElement.style.visibility = 'visible';
                gameOverModalElement.style.opacity = '1';
            }
            
            function resetGame() {
                score = 0; lives = 3; blocksPlaced = 0;
                gameGrid = Array(8).fill(null).map(() => Array(8).fill(0));
                askedQuestionIndices = []; gameIsOver = false; currentQuestionObject = null;
                scoreElement.textContent = `Score: ${score}`;
                livesElement.textContent = `Lives: ${lives}`;
                blocksPlacedElement.textContent = `Blocks Placed: 0/2`;
                questionsAnsweredElement.textContent = `Questions: 0/${networkingQuestions.length}`;
                initializeBoard();
                generateBlocks(); // Generate initial set of blocks
                checkGameEndConditions(); // Check if initial board state is already game over (highly unlikely but good practice)
                gameOverModalElement.style.visibility = 'hidden';
                gameOverModalElement.style.opacity = '0';
                tutorialOverlayElement.style.display = 'none';
            }
            
            restartBtnElement.addEventListener('click', resetGame);
            gameOverRestartBtnElement.addEventListener('click', resetGame);
            startGameBtnElement.addEventListener('click', function() {
                tutorialOverlayElement.style.display = 'none';
                resetGame();
            });
        });
    </script>
</body>
</html>