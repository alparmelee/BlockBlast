<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Managemnt</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1000px;
            gap: 20px;
        }
        .left-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #4fd1c5;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-align: center;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 2px;
            background-color: #555;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        .cell {
            width: 50px;
            height: 50px;
            background-color: #333;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .cell.filled {
            background-color: #4fd1c5;
        }
        .cell.highlight {
            background-color: #444; /* For valid placement */
        }
        .cell.highlight-invalid {
            background-color: #773333; /* For invalid placement attempt */
        }
        .blocks-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px; /* Gap from game board */
        }
        .block-selection {
            display: flex;
            flex-direction: column; /* Stack blocks vertically */
            gap: 15px; /* Space between blocks */
            margin-top: 20px;
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            min-width: 150px; /* Ensure it has some width */
        }
        .block {
            display: grid;
            gap: 2px;
            cursor: grab;
        }
        .block.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }
        .block-cell {
            width: 20px;
            height: 20px;
            background-color: #4fd1c5;
            border-radius: 2px;
        }
        .empty-cell { /* For spacing within a block's grid structure */
            width: 20px;
            height: 20px;
            background-color: transparent;
        }
        .score-panel {
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            width: 100%;
            min-width: 280px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        .score, .lives, .blocks-placed-count, .questions-answered-count {
            font-size: 1.2rem;
            margin-bottom: 8px;
        }
        .score { color: #4fd1c5; font-size: 1.4rem; }
        .lives { color: #f56565; }
        .blocks-placed-count { color: #d69e2e; }
        .questions-answered-count { color: #63b3ed; }

        .question-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            visibility: hidden; opacity: 0; transition: opacity 0.3s, visibility 0.3s;
        }
        .question-container {
            background-color: #333; padding: 30px; border-radius: 10px;
            max-width: 700px; 
            width: 90%; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .question-text { font-size: 1.2rem; margin-bottom: 10px; color: #4fd1c5; }
        .question-level-text { font-size: 0.9rem; margin-bottom: 15px; color: #aaa; }
        .answers { display: flex; flex-direction: column; gap: 10px; }
        .answer-btn {
            padding: 12px 15px; background-color: #4a5568; color: white;
            border: none; border-radius: 5px; cursor: pointer;
            font-size: 1rem; transition: background-color 0.2s; text-align: left;
            line-height: 1.4;
        }
        .answer-btn:hover { background-color: #2d3748; }

        .game-controls { display: flex; justify-content: center; gap: 20px; margin-top: 20px; }
        .control-btn {
            padding: 10px 20px; background-color: #4fd1c5; color: #222;
            border: none; border-radius: 5px; cursor: pointer;
            font-weight: bold; transition: background-color 0.2s;
        }
        .control-btn:hover { background-color: #38b2ac; }

        .game-over {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            visibility: hidden; opacity: 0; transition: opacity 0.3s, visibility 0.3s;
        }
        .game-over-container {
            background-color: #333; padding: 30px; border-radius: 10px;
            max-width: 400px; width: 90%; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .game-over-title { font-size: 2rem; color: #f56565; margin-bottom: 15px; }
        .final-score { font-size: 1.5rem; margin-bottom: 15px; }
        .game-over-message { font-size: 1.1rem; color: #ddd; margin-bottom: 25px; }
        .restart-btn {
            padding: 10px 25px; background-color: #4fd1c5; color: #222;
            border: none; border-radius: 5px; cursor: pointer;
            font-weight: bold; font-size: 1.1rem;
        }
        .restart-btn:hover { background-color: #38b2ac; }

        .tutorial-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
        }
        .tutorial-container {
            background-color: #333; padding: 30px; border-radius: 10px;
            max-width: 600px; width: 90%; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            text-align: left;
        }
        .tutorial-title { font-size: 1.8rem; color: #4fd1c5; margin-bottom: 15px; text-align: center;}
        .tutorial-content { margin-bottom: 20px; line-height: 1.6; }
        .tutorial-content ul { padding-left: 20px; }
        .start-game-btn {
            padding: 10px 25px; background-color: #4fd1c5; color: #222;
            border: none; border-radius: 5px; cursor: pointer;
            font-weight: bold; font-size: 1.1rem; display: block; margin: 20px auto 0 auto;
        }
    </style>
</head>
<body>
    <h1>Project Management - level 2</h1>
    
    <div class="game-container">
        <div class="left-panel">
            <div class="game-board" id="gameBoard"></div>
            <div class="score-panel">
                <div class="score" id="score">Score: 0</div>
                <div class="lives" id="lives">Lives: 3</div>
                <div class="blocks-placed-count" id="blocksPlaced">Blocks Placed: 0/2</div>
                <div class="questions-answered-count" id="questionsAnswered">Questions: 0/0</div>
            </div>
        </div>
        
        <div class="blocks-container">
            <h2>Available Blocks</h2>
            <div class="block-selection" id="blockSelection"></div>
            <div class="game-controls">
                <button class="control-btn" id="restartBtn">Restart Game</button>
            </div>
        </div>
    </div>
    
    <div class="question-modal" id="questionModal">
        <div class="question-container">
            <div class="question-text" id="questionText"></div>
            <div class="question-level-text" id="questionLevelText"></div>
            <div class="answers" id="answers"></div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <div class="game-over-container">
            <div class="game-over-title" id="gameOverTitle">Game Over!</div>
            <div class="final-score" id="finalScore">Your final score: 0</div>
            <div class="game-over-message" id="gameOverMessage"></div>
            <button class="restart-btn" id="gameOverRestartBtn">Play Again</button>
        </div>
    </div>

    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-container">
            <div class="tutorial-title">Welcome to BlockBlast - Networking Edition!</div>
            <div class="tutorial-content">
                <p><strong>How to play:</strong></p>
                <ul>
                    <li>Drag the Tetris-like blocks onto the 8x8 grid.</li>
                    <li>Complete a full row or column of 8 cells to clear it and earn points.</li>
                    <li>After placing 2 blocks, a networking question will appear.</li>
                    <li>Answer correctly for bonus points. Incorrect answers cost a life.</li>
                    <li>Lose 3 lives, or run out of moves/questions, and the game ends.</li>
                    <li>The game tracks the number of unique questions answered out of 20.</li>
                    <li>Try to get the highest score!</li>
                </ul>
            </div>
            <button class="start-game-btn" id="startGameBtn">Start Game</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let score = 0;
            let lives = 3;
            let blocksPlaced = 0;
            let gameGrid = Array(8).fill(null).map(() => Array(8).fill(0));
            let draggingBlock = null;
            let dragStartPos = { shapeClickRow: 0, shapeClickCol: 0 };
            const blockShapes = [
                { shape: [[1, 1, 1, 1]], color: '#FF5252' }, { shape: [[1, 0], [1, 0], [1, 1]], color: '#FFD740' },
                { shape: [[0, 1], [0, 1], [1, 1]], color: '#7C4DFF' }, { shape: [[1, 1], [1, 1]], color: '#FF4081' },
                { shape: [[1, 1, 1], [0, 1, 0]], color: '#64FFDA' }, { shape: [[1, 1, 0], [0, 1, 1]], color: '#18FFFF' },
                { shape: [[0, 1, 1], [1, 1, 0]], color: '#76FF03' }, { shape: [[1,1]], color: '#B388FF' },
                { shape: [[1,1,1]], color: '#FF9E80' }, { shape: [[1]], color: '#EA80FC' }
            ];
            
            let availableBlocks = [];
const networkingQuestions = [
    {
        question: "Scope",
        level: "Scope & Deliverables",
        answers: [
            "All the work involved in creating project products and the processes used to create them.", // Correct (Position 0)
            "The tangible or intangible results produced by a project.",
            "The approved version of the project scope statement, WBS, and WBS dictionary.",
            "Uncontrolled expansion of the project's goals without proper authorization."
        ],
        correctAnswer: 0
    },
    {
        question: "Deliverables",
        level: "Scope & Deliverables",
        answers: [
            "The sum of all products, services, and results to be provided by a project.",
            "The tangible or intangible results of a project, such as reports, software, or infrastructure.", // Correct (Position 1)
            "A hierarchical breakdown of the total scope of work.",
            "A document detailing how the project scope will be managed and controlled."
        ],
        correctAnswer: 1
    },
    {
        question: "Scope Baseline",
        level: "Scope & Deliverables",
        answers: [
            "The uncontrolled addition of features or work to a project.",
            "The process of formalizing acceptance of completed project deliverables.",
            "The approved version of the project scope, WBS, and WBS dictionary, used for comparison.", // Correct (Position 2)
            "The specific tasks that need to be performed to complete project work."
        ],
        correctAnswer: 2
    },
    {
        question: "Scope Creep",
        level: "Scope & Deliverables",
        answers: [
            "The initial approved project scope used as a reference point.",
            "A deliverable-oriented hierarchical decomposition of the work to be executed.",
            "The process of monitoring the status of the project scope and managing changes.",
            "The uncontrolled expansion of project scope without adjustments to time, cost, and resources." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Work Breakdown Structure (WBS)",
        level: "Scope & Deliverables",
        answers: [
            "A hierarchical decomposition of the project into manageable sections.", // Correct (Position 0)
            "All the work required to create the project's products and the processes to create them.",
            "The specific outputs or results that a project is expected to produce.",
            "A plan that describes how project scope will be defined, developed, and verified."
        ],
        correctAnswer: 0
    },
    {
        question: "Scope Management Plan",
        level: "Scope & Schedule Management",
        answers: [
            "The process of obtaining stakeholders' formal acceptance of project deliverables.",
            "A document outlining how the project scope will be defined, verified, controlled, and communicated.", // Correct (Position 1)
            "Monitoring project status and managing changes to the scope baseline.",
            "The approved version of the schedule model used for comparison to actual results."
        ],
        correctAnswer: 1
    },
    {
        question: "Validating Scope",
        level: "Scope & Schedule Management",
        answers: [
            "A plan detailing how project scope will be managed throughout the project lifecycle.",
            "The act of monitoring project scope and managing changes to the scope baseline.",
            "The process of obtaining formal acceptance of deliverables by stakeholders.", // Correct (Position 2)
            "The processes involved in ensuring the project is completed on time."
        ],
        correctAnswer: 2
    },
    {
        question: "Controlling Scope",
        level: "Scope & Schedule Management",
        answers: [
            "A document that describes how scope will be defined, validated, and controlled.",
            "The formal acceptance of the completed project deliverables.",
            "A significant event in a project schedule that marks progress but has no duration.",
            "Monitoring scope changes and managing adjustments to prevent scope creep." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Project Time Management",
        level: "Scope & Schedule Management",
        answers: [
            "Processes required to ensure the timely completion of a project.", // Correct (Position 0)
            "The approved project schedule used as a benchmark for tracking progress.",
            "A distinct, scheduled portion of work performed during the course of a project.",
            "A graphical display of project tasks and their dependencies."
        ],
        correctAnswer: 0
    },
    {
        question: "Schedule Baseline",
        level: "Scope & Schedule Management",
        answers: [
            "The set of processes needed to manage the timely completion of the project.",
            "The approved version of the schedule used to measure project progress.", // Correct (Position 1)
            "A specific task or unit of work with an expected duration and resources.",
            "A technique used to determine the shortest possible project duration."
        ],
        correctAnswer: 1
    },
    {
        question: "Activity",
        level: "Activity & Scheduling Concepts",
        answers: [
            "A significant event or point in a project schedule, often marking completion of a major deliverable.",
            "A diagram showing the sequence and dependencies of project activities.",
            "A specific task that consumes time and resources within a project.", // Correct (Position 2)
            "A bar chart illustrating the project schedule and task durations."
        ],
        correctAnswer: 2
    },
    {
        question: "Milestone",
        level: "Activity & Scheduling Concepts",
        answers: [
            "An individual piece of work that requires effort and time to complete.",
            "The sequence of activities that determines the earliest a project can be finished.",
            "A hierarchical chart of all project resources by category and type.",
            "A significant point in a project schedule with no duration but marks major progress." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Network Diagram",
        level: "Activity & Scheduling Concepts",
        answers: [
            "A graphical representation of activity sequencing in a project.", // Correct (Position 0)
            "A project scheduling technique that identifies the longest path of dependent tasks.",
            "A type of bar chart that illustrates a project schedule.",
            "The total number of work hours needed to complete a specific task."
        ],
        correctAnswer: 0
    },
    {
        question: "Critical Path Method (CPM)",
        level: "Activity & Scheduling Concepts",
        answers: [
            "A visual bar chart used to represent project tasks and their timelines.",
            "A technique for determining the longest sequence of dependent tasks to estimate total project duration.", // Correct (Position 1)
            "A significant event in the project schedule that has zero duration.",
            "Costs that are directly attributable to the project work, like labor and materials."
        ],
        correctAnswer: 1
    },
    {
        question: "Gantt Chart",
        level: "Activity & Scheduling Concepts",
        answers: [
            "A diagram illustrating the logical dependencies between project activities.",
            "The sequence of scheduled activities that determines the duration of the project.",
            "A bar chart that visually represents a project schedule over time.", // Correct (Position 2)
            "Benefits that can be measured in monetary terms, such as increased profits."
        ],
        correctAnswer: 2
    },
    {
        question: "Resource Breakdown Structure (RBS)",
        level: "Resource & Cost Management",
        answers: [
            "The total amount of labor, in hours or days, required to complete a task.",
            "Expenses incurred directly from executing project activities.",
            "Benefits that are difficult to quantify financially, like improved morale.",
            "A hierarchical structure of project resources categorized by type." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Effort",
        level: "Resource & Cost Management",
        answers: [
            "The total work hours required to complete an activity.", // Correct (Position 0)
            "A hierarchical list of all resources needed for a project, grouped by category.",
            "Costs that are not directly tied to a specific project but support overall operations.",
            "A relationship between project tasks where one must finish before another can start."
        ],
        correctAnswer: 0
    },
    {
        question: "Direct Costs",
        level: "Resource & Cost Management",
        answers: [
            "Quantifiable financial gains resulting from a project.",
            "Costs directly related to project execution, such as salaries and materials.", // Correct (Position 1)
            "Non-monetary advantages gained from a project, such as enhanced brand reputation.",
            "A required sequence between tasks due to inherent nature of the work."
        ],
        correctAnswer: 1
    },
    {
        question: "Tangible Benefits",
        level: "Resource & Cost Management",
        answers: [
            "Benefits that are not easily measured in monetary terms, like improved employee morale.",
            "Expenses directly incurred by the project, like labor and supplies.",
            "Benefits that can be quantified financially, such as increased revenue.", // Correct (Position 2)
            "A preferred order of tasks based on established best practices or team preference."
        ],
        correctAnswer: 2
    },
    {
        question: "Intangible Benefits",
        level: "Resource & Cost Management",
        answers: [
            "Financial gains that can be precisely calculated, such as cost savings.",
            "A document outlining how project risks will be identified and addressed.",
            "A formal procedure for proposing, evaluating, and approving project changes.",
            "Benefits that cannot be directly measured in financial terms, such as customer satisfaction." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Dependency",
        level: "Dependencies & Risk Management",
        answers: [
            "The relationship between two project tasks where one depends on another.", // Correct (Position 0)
            "A task sequence that is logically necessary for the work to be done correctly.",
            "A task sequence chosen based on team preference or best practice, not absolute necessity.",
            "The approved, time-phased budget against which project performance is measured."
        ],
        correctAnswer: 0
    },
    {
        question: "Mandatory Dependency",
        level: "Dependencies & Risk Management",
        answers: [
            "A preferred sequencing of tasks based on best practices or specific approaches.",
            "A required relationship, such as coding needing to be completed before testing.", // Correct (Position 1)
            "A comprehensive plan that details how project risks will be handled.",
            "A situation where actual project costs exceed the planned budget."
        ],
        correctAnswer: 1
    },
    {
        question: "Discretionary Dependency",
        level: "Dependencies & Risk Management",
        answers: [
            "A dependency that is inherent in the nature of the work or contractually required.",
            "A systematic process for managing modifications to the project.",
            "A preferred sequence based on best practices.", // Correct (Position 2)
            "A project management technique for measuring performance against scope, schedule, and cost baselines."
        ],
        correctAnswer: 2
    },
    {
        question: "Risk Management Plan",
        level: "Dependencies & Risk Management",
        answers: [
            "A formal process used to introduce and approve modifications to a project.",
            "The approved budget allocated over time for the project.",
            "A financial metric used to evaluate the efficiency of an investment.",
            "A document outlining how project risks will be identified, assessed, and managed." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Change Control",
        level: "Dependencies & Risk Management",
        answers: [
            "A formal process for managing project modifications.", // Correct (Position 0)
            "A document that describes the methodology for identifying, analyzing, and responding to project risks.",
            "When a project's actual expenditures surpass its allocated budget.",
            "The process of monitoring project expenditures and managing changes to the budget."
        ],
        correctAnswer: 0
    },
    {
        question: "Cost Baseline",
        level: "Budgeting & Cost Control",
        answers: [
            "A situation where a project's spending exceeds its planned financial limits.",
            "The approved, time-phased budget for a project.", // Correct (Position 1)
            "A methodology for integrating scope, schedule, and resource measurements to assess project performance.",
            "A performance measure used to evaluate the efficiency or profitability of an investment."
        ],
        correctAnswer: 1
    },
    {
        question: "Cost Overrun",
        level: "Budgeting & Cost Control",
        answers: [
            "The authorized, time-phased budget used as a reference for project performance.",
            "A technique to track project progress against planned value, earned value, and actual cost.",
            "When actual costs exceed estimated costs.", // Correct (Position 2)
            "The process of influencing and managing factors that create changes to the project budget."
        ],
        correctAnswer: 2
    },
    {
        question: "Earned Value Management (EVM)",
        level: "Budgeting & Cost Control",
        answers: [
            "The approved budget against which project execution is compared.",
            "A calculation of the monetary benefits received in relation to the investment cost.",
            "The procedures for monitoring expenditures and managing budget variances.",
            "A technique to measure project performance in terms of scope, schedule, and cost." // Correct (Position 3)
        ],
        correctAnswer: 3
    },
    {
        question: "Return on Investment (ROI)",
        level: "Budgeting & Cost Control",
        answers: [
            "A financial metric evaluating the profitability of a project.", // Correct (Position 0)
            "The planned, approved budget over the project's duration.",
            "A project management methodology that integrates scope, schedule, and cost data.",
            "The ongoing process of tracking project spending against the budget."
        ],
        correctAnswer: 0
    },
    {
        question: "Controlling Costs",
        level: "Budgeting & Cost Control",
        answers: [
            "The authorized budget used to measure and monitor cost performance.",
            "The process of tracking and managing budget adjustments.", // Correct (Position 1)
            "When the actual expenses of a project are higher than the planned expenses.",
            "A method for evaluating the financial return of a project relative to its cost."
        ],
        correctAnswer: 1
    }
];
            let askedQuestionIndices = [];
            let currentQuestionObject = null;
            let gameIsOver = false;
            
            const gameBoardElement = document.getElementById('gameBoard');
            const blockSelectionElement = document.getElementById('blockSelection');
            const scoreElement = document.getElementById('score');
            const livesElement = document.getElementById('lives');
            const blocksPlacedElement = document.getElementById('blocksPlaced');
            const questionsAnsweredElement = document.getElementById('questionsAnswered');
            const questionModalElement = document.getElementById('questionModal');
            const questionTextElement = document.getElementById('questionText');
            const questionLevelTextElement = document.getElementById('questionLevelText');
            const answersContainerElement = document.getElementById('answers');
            const gameOverModalElement = document.getElementById('gameOver');
            const finalScoreElement = document.getElementById('finalScore');
            const gameOverTitleElement = document.getElementById('gameOverTitle');
            const gameOverMessageElement = document.getElementById('gameOverMessage');
            const restartBtnElement = document.getElementById('restartBtn');
            const gameOverRestartBtnElement = document.getElementById('gameOverRestartBtn');
            const tutorialOverlayElement = document.getElementById('tutorialOverlay');
            const startGameBtnElement = document.getElementById('startGameBtn');
            
            function initializeBoard() {
                gameBoardElement.innerHTML = '';
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        gameBoardElement.appendChild(cell);
                        cell.addEventListener('dragover', allowDrop);
                        cell.addEventListener('drop', dropBlock);
                        cell.addEventListener('dragenter', function(e) {
                            if (draggingBlock) {
                                const r = parseInt(e.target.dataset.row);
                                const c = parseInt(e.target.dataset.col);
                                highlightValidCells(r, c, draggingBlock.shape);
                            }
                        });
                        cell.addEventListener('dragleave', clearHighlight);
                    }
                }
                updateBoardVisuals();
            }
            
            function generateBlocks() {
                blockSelectionElement.innerHTML = '';
                availableBlocks = [];
                const numBlocksToGenerate = Math.min(3, blockShapes.length);
                for (let i = 0; i < numBlocksToGenerate; i++) {
                    const randomIndex = Math.floor(Math.random() * blockShapes.length);
                    const blockData = blockShapes[randomIndex];
                    const newBlock = {
                        shape: blockData.shape,
                        color: blockData.color,
                        id: `block-${Date.now()}-${i}`
                    };
                    availableBlocks.push(newBlock);
                    createBlockElement(newBlock.shape, newBlock.color, newBlock.id);
                }
            }
            
            function createBlockElement(shape, color, id) {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'block';
                blockDiv.id = id;
                blockDiv.draggable = true;
                const rows = shape.length;
                const cols = shape[0] ? shape[0].length : 0;
                blockDiv.style.gridTemplateColumns = `repeat(${cols}, 20px)`;
                blockDiv.style.gridTemplateRows = `repeat(${rows}, 20px)`;
                for (let r_shape = 0; r_shape < rows; r_shape++) {
                    for (let c_shape = 0; c_shape < cols; c_shape++) {
                        const cell = document.createElement('div');
                        if (shape[r_shape] && shape[r_shape][c_shape] === 1) {
                            cell.className = 'block-cell';
                            cell.style.backgroundColor = color;
                        } else {
                            cell.className = 'empty-cell';
                        }
                        blockDiv.appendChild(cell);
                    }
                }
                blockDiv.addEventListener('dragstart', function(e) {
                    draggingBlock = availableBlocks.find(b => b.id === id);
                    if (!draggingBlock) return;
                    e.dataTransfer.setData('text/plain', id);
                    e.target.classList.add('dragging');
                    let clickedShapeRow = 0, clickedShapeCol = 0;
                    const blockCells = e.target.querySelectorAll('.block-cell, .empty-cell');
                    blockCells.forEach((cell, index) => {
                        const cellRect = cell.getBoundingClientRect();
                        if (e.clientX >= cellRect.left && e.clientX < cellRect.right &&
                            e.clientY >= cellRect.top && e.clientY < cellRect.bottom) {
                            clickedShapeRow = Math.floor(index / cols);
                            clickedShapeCol = index % cols;
                        }
                    });
                    dragStartPos = { shapeClickRow: clickedShapeRow, shapeClickCol: clickedShapeCol };
                });
                blockDiv.addEventListener('dragend', function(e) {
                    e.target.classList.remove('dragging');
                    clearHighlight();
                    draggingBlock = null;
                });
                blockSelectionElement.appendChild(blockDiv);
            }
            
            function updateBoardVisuals() {
                gameBoardElement.querySelectorAll('.cell').forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    cell.className = 'cell'; 
                    if (gameGrid[row][col] === 1) cell.classList.add('filled');
                });
            }

            function highlightValidCells(boardCellRow, boardCellCol, shape) {
                clearHighlight();
                if (!draggingBlock) return;
                const startRow = boardCellRow - dragStartPos.shapeClickRow;
                const startCol = boardCellCol - dragStartPos.shapeClickCol;
                let canPlaceCurrent = true;
                for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                    for (let c_shape = 0; c_shape < (shape[r_shape] ? shape[r_shape].length : 0); c_shape++) {
                        if (shape[r_shape][c_shape] === 1) {
                            const R_board = startRow + r_shape;
                            const C_board = startCol + c_shape;
                            if (R_board < 0 || R_board >= 8 || C_board < 0 || C_board >= 8 || gameGrid[R_board][C_board] === 1) {
                                canPlaceCurrent = false;
                            }
                        }
                    }
                }
                for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                    for (let c_shape = 0; c_shape < (shape[r_shape] ? shape[r_shape].length : 0); c_shape++) {
                        if (shape[r_shape][c_shape] === 1) {
                            const R_board = startRow + r_shape;
                            const C_board = startCol + c_shape;
                            if (R_board >= 0 && R_board < 8 && C_board >= 0 && C_board < 8) {
                                const cellElement = gameBoardElement.querySelector(`.cell[data-row="${R_board}"][data-col="${C_board}"]`);
                                if (cellElement) {
                                    cellElement.classList.add(canPlaceCurrent && gameGrid[R_board][C_board] === 0 ? 'highlight' : 'highlight-invalid');
                                }
                            }
                        }
                    }
                }
            }
            
            function clearHighlight() {
                gameBoardElement.querySelectorAll('.cell.highlight, .cell.highlight-invalid').forEach(cell => {
                    cell.classList.remove('highlight', 'highlight-invalid');
                });
            }
            
            function allowDrop(e) { e.preventDefault(); }
            
            function dropBlock(e) {
                e.preventDefault();
                if (!draggingBlock) return;
                const targetCell = e.target.closest('.cell');
                if (!targetCell) { draggingBlock = null; clearHighlight(); return; }
                const boardCellRow = parseInt(targetCell.dataset.row);
                const boardCellCol = parseInt(targetCell.dataset.col);
                const startRow = boardCellRow - dragStartPos.shapeClickRow;
                const startCol = boardCellCol - dragStartPos.shapeClickCol;
                
                if (canPlaceBlock(draggingBlock.shape, startRow, startCol)) {
                    placeBlockOnGrid(draggingBlock.shape, startRow, startCol);
                    document.getElementById(draggingBlock.id)?.remove();
                    availableBlocks = availableBlocks.filter(b => b.id !== draggingBlock.id);
                    checkCompletedLines(); // This might call checkGameEndConditions indirectly if lines clear
                    blocksPlaced++;
                    blocksPlacedElement.textContent = `Blocks Placed: ${blocksPlaced % 2}/2`;
                    if (blocksPlaced % 2 === 0) {
                         setTimeout(showQuestion, 300);
                    } else { // If not showing a question, check end conditions now
                        checkGameEndConditions();
                    }
                    if (availableBlocks.length === 0 && networkingQuestions.length > askedQuestionIndices.length) {
                        generateBlocks();
                    }
                } else { // If block couldn't be placed, still check end conditions
                     checkGameEndConditions();
                }
                draggingBlock = null;
                clearHighlight();
            }

            function canPlaceBlock(shape, startRow, startCol) {
                for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                    for (let c_shape = 0; c_shape < (shape[r_shape] ? shape[r_shape].length : 0); c_shape++) {
                        if (shape[r_shape][c_shape] === 1) {
                            const R_board = startRow + r_shape;
                            const C_board = startCol + c_shape;
                            if (R_board < 0 || R_board >= 8 || C_board < 0 || C_board >= 8 || gameGrid[R_board][C_board] === 1) return false;
                        }
                    }
                }
                return true;
            }

            function canAnyBlockFromListFit(blockList) {
                if (!blockList || blockList.length === 0) return false;
                for (const block of blockList) {
                    const shapeToTest = block.shape;
                    for (let r_board_anchor = 0; r_board_anchor < 8; r_board_anchor++) {
                        for (let c_board_anchor = 0; c_board_anchor < 8; c_board_anchor++) {
                            for (let sr = 0; sr < shapeToTest.length; sr++) {
                                for (let sc = 0; sc < (shapeToTest[sr] ? shapeToTest[sr].length : 0); sc++) {
                                    if (shapeToTest[sr][sc] === 1) {
                                        const potentialStartRow = r_board_anchor - sr;
                                        const potentialStartCol = c_board_anchor - sc;
                                        if (canPlaceBlock(shapeToTest, potentialStartRow, potentialStartCol)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            }

            function canAnyNewShapeFit() {
                for (const baseBlock of blockShapes) {
                    const shapeToTest = baseBlock.shape;
                     for (let r_board_anchor = 0; r_board_anchor < 8; r_board_anchor++) {
                        for (let c_board_anchor = 0; c_board_anchor < 8; c_board_anchor++) {
                            for (let sr = 0; sr < shapeToTest.length; sr++) {
                                for (let sc = 0; sc < (shapeToTest[sr] ? shapeToTest[sr].length : 0); sc++) {
                                    if (shapeToTest[sr][sc] === 1) {
                                        const potentialStartRow = r_board_anchor - sr;
                                        const potentialStartCol = c_board_anchor - sc;
                                        if (canPlaceBlock(shapeToTest, potentialStartRow, potentialStartCol)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            }

            function placeBlockOnGrid(shape, startRow, startCol) {
                for (let r_shape = 0; r_shape < shape.length; r_shape++) {
                    for (let c_shape = 0; c_shape < (shape[r_shape] ? shape[r_shape].length : 0); c_shape++) {
                        if (shape[r_shape][c_shape] === 1) {
                             const R_board = startRow + r_shape;
                             const C_board = startCol + c_shape;
                             if (R_board >= 0 && R_board < 8 && C_board >= 0 && C_board < 8) gameGrid[R_board][C_board] = 1;
                        }
                    }
                }
                updateBoardVisuals();
            }
            
            function checkCompletedLines() {
                let rowsToClear = [], colsToClear = [];
                for (let i = 0; i < 8; i++) {
                    if (gameGrid[i].every(cell => cell === 1)) rowsToClear.push(i);
                    let colIsFull = true;
                    for(let k=0; k<8; k++) if(gameGrid[k][i] === 0) {colIsFull = false; break;}
                    if(colIsFull) colsToClear.push(i);
                }
                if (rowsToClear.length > 0 || colsToClear.length > 0) {
                    setTimeout(() => {
                        clearLines(rowsToClear, colsToClear);
                        updateScore((rowsToClear.length + colsToClear.length) * 100);
                        // After clearing lines, new spaces might open up, so check game end conditions again.
                        // Also, if new blocks are needed and can be generated, do it.
                        if (availableBlocks.length === 0 && networkingQuestions.length > askedQuestionIndices.length) {
                            generateBlocks();
                        }
                        checkGameEndConditions();
                    }, 150); 
                } else {
                    // If no lines cleared, still check game end conditions as a block was just placed.
                    checkGameEndConditions();
                }
            }

            function clearLines(rows, cols) {
                rows.forEach(rowIndex => gameGrid[rowIndex].fill(0));
                cols.forEach(colIndex => gameGrid.forEach(row => row[colIndex] = 0));
                // Row gravity
                rows.sort((a, b) => b - a); 
                rows.forEach(clearedRowIndex => {
                    for (let r = clearedRowIndex; r > 0; r--) gameGrid[r] = [...gameGrid[r-1]];
                    gameGrid[0].fill(0);
                });
                // Column gravity (simplified - only if a full column was cleared, shift from right to left if implementing)
                // For this version, we'll stick to dominant row gravity which is more common.
                updateBoardVisuals();
            }
            
            function updateScore(points) {
                score += points;
                scoreElement.textContent = `Score: ${score}`;
            }
            
            function showQuestion() {
                if (gameIsOver) return;
                if (askedQuestionIndices.length >= networkingQuestions.length) {
                    checkGameEndConditions(); return;
                }
                let questionIndex;
                do { questionIndex = Math.floor(Math.random() * networkingQuestions.length); }
                while (askedQuestionIndices.includes(questionIndex));
                askedQuestionIndices.push(questionIndex);
                currentQuestionObject = networkingQuestions[questionIndex];
                questionTextElement.textContent = currentQuestionObject.question;
                questionLevelTextElement.textContent = `Level: ${currentQuestionObject.level}`;
                questionsAnsweredElement.textContent = `Questions: ${askedQuestionIndices.length}/${networkingQuestions.length}`;
                answersContainerElement.innerHTML = '';
                currentQuestionObject.answers.forEach((answer, index) => {
                    const button = document.createElement('button');
                    button.className = 'answer-btn';
                    button.textContent = answer;
                    button.dataset.index = index;
                    button.addEventListener('click', handleAnswer);
                    answersContainerElement.appendChild(button);
                });
                questionModalElement.style.visibility = 'visible';
                questionModalElement.style.opacity = '1';
            }

            function handleAnswer(event) {
                if (gameIsOver || !currentQuestionObject) return;
                const answerIndex = parseInt(event.target.dataset.index);
                if (answerIndex === currentQuestionObject.correctAnswer) {
                    updateScore(50);
                } else {
                    lives--;
                    livesElement.textContent = `Lives: ${lives}`;
                }
                hideQuestionModal();
                currentQuestionObject = null;
                checkGameEndConditions(); // Critical to check after answer processed
            }

            function checkGameEndConditions() {
                if (gameIsOver) return;
                if (lives <= 0) { endGame("No lives left!"); return; }
                
                const allQuestionsAnswered = askedQuestionIndices.length >= networkingQuestions.length;

                if (allQuestionsAnswered) { // If all questions are done, game ends if no more moves
                    if (availableBlocks.length === 0 || !canAnyBlockFromListFit(availableBlocks)) {
                        endGame("All questions answered and no more moves!");
                        return;
                    }
                }
                
                // Standard game over conditions if questions remain or even if all answered but moves still exist
                if (availableBlocks.length === 0 && !canAnyNewShapeFit()) {
                    endGame("No more blocks and no new shapes can fit!");
                    return;
                }
                if (availableBlocks.length > 0 && !canAnyBlockFromListFit(availableBlocks)) {
                     endGame("No more valid moves with available blocks!");
                     return;
                }
            }
            
            function hideQuestionModal() {
                questionModalElement.style.visibility = 'hidden';
                questionModalElement.style.opacity = '0';
            }
            
            function endGame(reason = "Game Over!") {
                if (gameIsOver) return;
                gameIsOver = true;
                gameOverTitleElement.textContent = "Game Over!";
                gameOverMessageElement.textContent = reason;
                finalScoreElement.textContent = `Your final score: ${score}`;
                gameOverModalElement.style.visibility = 'visible';
                gameOverModalElement.style.opacity = '1';
            }
            
            function resetGame() {
                score = 0; lives = 3; blocksPlaced = 0;
                gameGrid = Array(8).fill(null).map(() => Array(8).fill(0));
                askedQuestionIndices = []; gameIsOver = false; currentQuestionObject = null;
                scoreElement.textContent = `Score: ${score}`;
                livesElement.textContent = `Lives: ${lives}`;
                blocksPlacedElement.textContent = `Blocks Placed: 0/2`;
                questionsAnsweredElement.textContent = `Questions: 0/${networkingQuestions.length}`;
                initializeBoard();
                generateBlocks(); // Generate initial set of blocks
                checkGameEndConditions(); // Check if initial board state is already game over (highly unlikely but good practice)
                gameOverModalElement.style.visibility = 'hidden';
                gameOverModalElement.style.opacity = '0';
                tutorialOverlayElement.style.display = 'none';
            }
            
            restartBtnElement.addEventListener('click', resetGame);
            gameOverRestartBtnElement.addEventListener('click', resetGame);
            startGameBtnElement.addEventListener('click', function() {
                tutorialOverlayElement.style.display = 'none';
                resetGame();
            });
        });
    </script>
</body>
</html>